{"code":"import { __decorate } from \"tslib\";\r\nimport { ReactiveElement } from \"lit\";\r\nimport { property } from \"lit/decorators\";\r\nimport memoizeOne from \"memoize-one\";\r\nimport { navigate } from \"./frontend_release/common/navigate\";\r\n//Based on hass-router-page.ts (src/layouts/hass-router-page)\r\nconst extractPage = (path, defaultPage) => {\r\n    if (path === \"\") {\r\n        return defaultPage;\r\n    }\r\n    const subpathStart = path.indexOf(\"/\", 1);\r\n    return subpathStart === -1\r\n        ? path.substr(1)\r\n        : path.substr(1, subpathStart - 1);\r\n};\r\n// Time to wait for code to load before we show loading screen.\r\nconst LOADING_SCREEN_THRESHOLD = 400; // ms\r\nexport class RacelandRouterPage extends ReactiveElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._currentPage = \"\";\r\n        this._cache = {};\r\n        this._initialLoadDone = false;\r\n        this._computeTail = memoizeOne((route) => {\r\n            const dividerPos = route.path.indexOf(\"/\", 1);\r\n            return dividerPos === -1\r\n                ? {\r\n                    prefix: route.prefix + route.path,\r\n                    path: \"\",\r\n                }\r\n                : {\r\n                    prefix: route.prefix + route.path.substr(0, dividerPos),\r\n                    path: route.path.substr(dividerPos),\r\n                };\r\n        });\r\n    }\r\n    createRenderRoot() {\r\n        return this;\r\n    }\r\n    update(changedProps) {\r\n        super.update(changedProps);\r\n        const routerOptions = this.routerOptions || { routes: {} };\r\n        if (routerOptions && routerOptions.initialLoad && !this._initialLoadDone) {\r\n            return;\r\n        }\r\n        if (!changedProps.has(\"route\")) {\r\n            // Do not update if we have a currentLoadProm, because that means\r\n            // that there is still an old panel shown and we're moving to a new one.\r\n            if (this.lastChild && !this._currentLoadProm) {\r\n                this.updatePageEl(this.lastChild, changedProps);\r\n            }\r\n            return;\r\n        }\r\n        const route = this.route;\r\n        const defaultPage = routerOptions.defaultPage;\r\n        if (route && route.path === \"\" && defaultPage !== undefined) {\r\n            navigate(`${route.prefix}/${defaultPage}`, { replace: true });\r\n        }\r\n        let newPage = route\r\n            ? extractPage(route.path, defaultPage || \"\")\r\n            : \"not_found\";\r\n        let routeOptions = routerOptions.routes[newPage];\r\n        // Handle redirects\r\n        while (typeof routeOptions === \"string\") {\r\n            newPage = routeOptions;\r\n            routeOptions = routerOptions.routes[newPage];\r\n        }\r\n        if (routerOptions.beforeRender) {\r\n            const result = routerOptions.beforeRender(newPage);\r\n            if (result !== undefined) {\r\n                newPage = result;\r\n                routeOptions = routerOptions.routes[newPage];\r\n                // Handle redirects\r\n                while (typeof routeOptions === \"string\") {\r\n                    newPage = routeOptions;\r\n                    routeOptions = routerOptions.routes[newPage];\r\n                }\r\n                // Update the url if we know where we're mounted.\r\n                if (route) {\r\n                    navigate(`${route.prefix}/${result}${location.search}`, {\r\n                        replace: true,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (this._currentPage === newPage) {\r\n            if (this.lastChild) {\r\n                this.updatePageEl(this.lastChild, changedProps);\r\n            }\r\n            return;\r\n        }\r\n        if (!routeOptions) {\r\n            this._currentPage = \"\";\r\n            if (this.lastChild) {\r\n                this.removeChild(this.lastChild);\r\n            }\r\n            return;\r\n        }\r\n        this._currentPage = newPage;\r\n        const loadProm = routeOptions.load\r\n            ? routeOptions.load()\r\n            : Promise.resolve();\r\n        let showLoadingScreenTimeout;\r\n        // Check when loading the page source failed.\r\n        loadProm.catch((err) => {\r\n            // eslint-disable-next-line\r\n            console.error(\"Error loading page\", newPage, err);\r\n            // Verify that we're still trying to show the same page.\r\n            if (this._currentPage !== newPage) {\r\n                return;\r\n            }\r\n            // Removes either loading screen or the panel\r\n            if (this.lastChild) {\r\n                this.removeChild(this.lastChild);\r\n            }\r\n            if (showLoadingScreenTimeout) {\r\n                clearTimeout(showLoadingScreenTimeout);\r\n            }\r\n            // Show error screen\r\n            this.appendChild(this.createErrorScreen(`Error while loading page ${newPage}.`));\r\n        });\r\n        // If we don't show loading screen, just show the panel.\r\n        // It will be automatically upgraded when loading done.\r\n        if (!routerOptions.showLoading) {\r\n            this._createPanel(routerOptions, newPage, routeOptions);\r\n            return;\r\n        }\r\n        // We are only going to show the loading screen after some time.\r\n        // That way we won't have a double fast flash on fast connections.\r\n        let created = false;\r\n        showLoadingScreenTimeout = window.setTimeout(() => {\r\n            if (created || this._currentPage !== newPage) {\r\n                return;\r\n            }\r\n            // Show a loading screen.\r\n            if (this.lastChild) {\r\n                this.removeChild(this.lastChild);\r\n            }\r\n            this.appendChild(this.createLoadingScreen());\r\n        }, LOADING_SCREEN_THRESHOLD);\r\n        this._currentLoadProm = loadProm.then(() => {\r\n            this._currentLoadProm = undefined;\r\n            // Check if we're still trying to show the same page.\r\n            if (this._currentPage !== newPage) {\r\n                return;\r\n            }\r\n            created = true;\r\n            this._createPanel(routerOptions, newPage, \r\n            // @ts-ignore TS forgot this is not a string.\r\n            routeOptions);\r\n        }, () => {\r\n            this._currentLoadProm = undefined;\r\n        });\r\n    }\r\n    firstUpdated(changedProps) {\r\n        super.firstUpdated(changedProps);\r\n        const options = this.routerOptions;\r\n        if (!options) {\r\n            return;\r\n        }\r\n        if (options.preloadAll) {\r\n            Object.values(options.routes).forEach((route) => typeof route === \"object\" && route.load && route.load());\r\n        }\r\n        if (options.initialLoad) {\r\n            setTimeout(() => {\r\n                if (!this._initialLoadDone) {\r\n                    this.appendChild(this.createLoadingScreen());\r\n                }\r\n            }, LOADING_SCREEN_THRESHOLD);\r\n            options.initialLoad().then(() => {\r\n                this._initialLoadDone = true;\r\n                this.requestUpdate(\"route\");\r\n            });\r\n        }\r\n    }\r\n    createLoadingScreen() {\r\n        return document.createElement(\"hass-loading-screen\");\r\n    }\r\n    createErrorScreen(error) {\r\n        const errorEl = document.createElement(\"hass-error-screen\");\r\n        errorEl.error = error;\r\n        return errorEl;\r\n    }\r\n    /**\r\n     * Rebuild the current panel.\r\n     *\r\n     * Promise will resolve when rebuilding is done and DOM updated.\r\n     */\r\n    async rebuild() {\r\n        const oldRoute = this.route;\r\n        if (oldRoute === undefined) {\r\n            return;\r\n        }\r\n        this.route = undefined;\r\n        await this.updateComplete;\r\n        // Make sure that the parent didn't override this in the meanwhile.\r\n        if (this.route === undefined) {\r\n            this.route = oldRoute;\r\n        }\r\n    }\r\n    /**\r\n     * Promise that resolves when the page has rendered.\r\n     */\r\n    get pageRendered() {\r\n        return this.updateComplete.then(() => this._currentLoadProm);\r\n    }\r\n    createElement(tag) {\r\n        return document.createElement(tag);\r\n    }\r\n    updatePageEl(_pageEl, _changedProps) {\r\n        // default we do nothing\r\n    }\r\n    get routeTail() {\r\n        return this._computeTail(this.route);\r\n    }\r\n    _createPanel(routerOptions, page, routeOptions) {\r\n        if (this.lastChild) {\r\n            this.removeChild(this.lastChild);\r\n        }\r\n        const panelEl = this._cache[page] || this.createElement(routeOptions.tag);\r\n        this.updatePageEl(panelEl);\r\n        this.appendChild(panelEl);\r\n        if (routerOptions.cacheAll || routeOptions.cache) {\r\n            this._cache[page] = panelEl;\r\n        }\r\n    }\r\n}\r\n__decorate([\r\n    property()\r\n], RacelandRouterPage.prototype, \"route\", void 0);\r\n","references":["/workspaces/RacelandHA/config/www/raceland-dashboard/node_modules/lit/index.d.ts","/workspaces/RacelandHA/config/www/raceland-dashboard/node_modules/lit/decorators.d.ts","/workspaces/RacelandHA/config/www/raceland-dashboard/src/types.ts","/workspaces/RacelandHA/config/www/raceland-dashboard/node_modules/memoize-one/dist/memoize-one.d.ts","/workspaces/RacelandHA/config/www/raceland-dashboard/src/frontend_release/common/navigate.ts"]}
